<!DOCTYPE html>
<html>
<head>
    <title>SIP-WebRTC Gateway with Video</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }

        .controls {
            margin-bottom: 20px;
        }

            .controls input {
                padding: 8px;
                margin-right: 10px;
                width: 250px;
            }

            .controls button {
                padding: 8px 16px;
                margin-right: 10px;
            }

        .video-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .video-section {
            flex: 1;
        }

            .video-section h3 {
                margin-top: 0;
            }

        video {
            width: 100%;
            max-width: 400px;
            height: 300px;
            background-color: #000;
            border: 1px solid #ccc;
        }

        audio {
            width: 100%;
            margin-top: 10px;
        }

        .media-options {
            margin: 15px 0;
        }

            .media-options label {
                margin-right: 15px;
            }
    </style>
</head>
<body>
    <h1>SIP-WebRTC Gateway with Video Support</h1>

    <div class="controls">
        <input type="text" id="sipUri" placeholder="sip:user@domain.com" />
        <button onclick="makeCall()">Make Call</button>
        <button onclick="hangUp()">Hang Up</button>
    </div>

    <div class="media-options">
        <label>
            <input type="checkbox" id="enableVideo" checked> Enable Video
        </label>
        <label>
            <input type="checkbox" id="enableAudio" checked> Enable Audio
        </label>
    </div>

    <div class="video-container">
        <div class="video-section">
            <h3>Local Stream</h3>
            <video id="localVideo" autoplay muted></video>
            <audio id="localAudio" autoplay muted></audio>
        </div>
        <div class="video-section">
            <h3>Remote Stream</h3>
            <video id="remoteVideo" autoplay></video>
            <audio id="remoteAudio" autoplay></audio>
        </div>
    </div>

    <script>
        let ws;
        let peerConnection;
        let localStream;
        const sessionId = generateSessionId();

        // WebSocket connection to gateway
        ws = new WebSocket(`ws://localhost:8080/sip?sessionId=${sessionId}`);
        ws.onmessage = handleWebSocketMessage;
        ws.onopen = () => console.log('WebSocket connected');
        ws.onerror = (error) => console.error('WebSocket error:', error);

        // WebRTC configuration
        const rtcConfig = {
            iceServers: [
                {
                    urls: 'turn:172.27.200.242:3478',
                    username: 'username1',
                    credential: 'password1'
                }
            ]
        };

        async function initializeWebRTC() {
            try {
                peerConnection = new RTCPeerConnection(rtcConfig);

                // Get media constraints based on checkboxes
                const enableVideo = document.getElementById('enableVideo').checked;
                const enableAudio = document.getElementById('enableAudio').checked;

                const constraints = {
                    video: enableVideo ? {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    } : false,
                    audio: enableAudio ? {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } : false
                };

                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia(constraints);

                // Display local stream
                const localVideo = document.getElementById('localVideo');
                const localAudio = document.getElementById('localAudio');

                if (enableVideo) {
                    localVideo.srcObject = localStream;
                    localVideo.style.display = 'block';
                } else {
                    localVideo.style.display = 'none';
                }

                if (enableAudio && !enableVideo) {
                    localAudio.srcObject = localStream;
                    localAudio.style.display = 'block';
                } else {
                    localAudio.style.display = 'none';
                }

                // Add local tracks to peer connection
                localStream.getTracks().forEach(track => {
                    console.log('Adding track:', track.kind);
                    peerConnection.addTrack(track, localStream);
                });

                // Handle remote stream
                peerConnection.ontrack = (event) => {
                    console.log('Received remote track:', event.track.kind);
                    const remoteVideo = document.getElementById('remoteVideo');
                    const remoteAudio = document.getElementById('remoteAudio');

                    if (event.track.kind === 'video') {
                        remoteVideo.srcObject = event.streams[0];
                        remoteVideo.style.display = 'block';
                    } else if (event.track.kind === 'audio') {
                        if (!remoteVideo.srcObject) {
                            remoteAudio.srcObject = event.streams[0];
                            remoteAudio.style.display = 'block';
                        }
                    }
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('Sending ICE candidate');
                        sendWebSocketMessage('ice-candidate', event.candidate);
                    }
                };

                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', peerConnection.connectionState);
                };

                // Handle ICE connection state changes
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', peerConnection.iceConnectionState);
                };

            } catch (error) {
                console.error('Error initializing WebRTC:', error);
                alert('Error accessing media devices: ' + error.message);
            }
        }

        async function makeCall() {
            const sipUri = document.getElementById('sipUri').value.trim();
            if (!sipUri) {
                alert('Please enter a SIP URI');
                return;
            }

            try {
                await initializeWebRTC();
                console.log('Making call to:', sipUri);
                sendWebSocketMessage('make-call', sipUri);
            } catch (error) {
                console.error('Error making call:', error);
                alert('Error making call: ' + error.message);
            }
        }

        async function handleWebSocketMessage(event) {
            try {
                const message = JSON.parse(event.data);
                console.log('Received message:', message.type);

                switch (message.type) {
                    case 'offer':
                        await handleOffer(message.data);
                        break;
                    case 'answer':
                        await handleAnswer(message.data);
                        break;
                    case 'ice-candidate':
                        await handleIceCandidate(message.data);
                        break;
                    case 'incoming-call':
                        await handleIncomingCall(message.data);
                        break;
                    case 'call-ended':
                        handleCallEnded();
                        break;
                    case 'error':
                        console.error('Server error:', message.data);
                        alert('Call error: ' + message.data);
                        break;
                }
            } catch (error) {
                console.error('Error handling WebSocket message:', error);
            }
        }

        async function handleOffer(offer) {
            try {
                await initializeWebRTC();
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                console.log('Sending answer');
                sendWebSocketMessage('answer', answer);
            } catch (error) {
                console.error('Error handling offer:', error);
            }
        }

        async function handleAnswer(answer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                console.log('Answer set successfully');
            } catch (error) {
                console.error('Error handling answer:', error);
            }
        }

        async function handleIceCandidate(candidate) {
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.log('ICE candidate added successfully');
            } catch (error) {
                console.error('Error handling ICE candidate:', error);
            }
        }

        async function handleIncomingCall(fromUri) {
            if (confirm(`Incoming call from ${fromUri}. Accept?`)) {
                try {
                    await initializeWebRTC();

                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    console.log('Accepting incoming call, sending offer');
                    sendWebSocketMessage('accept-call', offer);
                } catch (error) {
                    console.error('Error accepting call:', error);
                    sendWebSocketMessage('reject-call', null);
                }
            } else {
                sendWebSocketMessage('reject-call', null);
            }
        }

        function handleCallEnded() {
            console.log('Call ended by remote party');
            cleanupCall();
        }

        function sendWebSocketMessage(type, data) {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    sessionId: sessionId,
                    type: type,
                    data: data
                }));
            } else {
                console.error('WebSocket not connected');
            }
        }

        function generateSessionId() {
            return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }

        function hangUp() {
            console.log('Hanging up call');
            cleanupCall();
            sendWebSocketMessage('hang-up', null);
        }

        function cleanupCall() {
            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Stopped track:', track.kind);
                });
                localStream = null;
            }

            // Clear video elements
            const localVideo = document.getElementById('localVideo');
            const localAudio = document.getElementById('localAudio');
            const remoteVideo = document.getElementById('remoteVideo');
            const remoteAudio = document.getElementById('remoteAudio');

            localVideo.srcObject = null;
            localAudio.srcObject = null;
            remoteVideo.srcObject = null;
            remoteAudio.srcObject = null;

            localVideo.style.display = 'none';
            localAudio.style.display = 'none';
            remoteVideo.style.display = 'none';
            remoteAudio.style.display = 'none';
        }

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            cleanupCall();
        });
    </script>
</body>
</html>